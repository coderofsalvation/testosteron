#!/bin/bash
#
# Shellscript conventions:
#   - functions starting with '_' are private functions and not exposed to cli (but can be invoked from cli)
#   - functions starting without '_' are exposed to cli
#   - functions starting without '_' automatically document themselves in the cli if you add a comment above them
#   - internal (saved) config variables are possible using _set-variable and _get-variable
#
#
# Absolute path to this script, e.g. /home/user/bin/foo.sh
SELF_ABS=`readlink -f $0`
# Absolute path this script is in, thus /home/user/bin
SELF_PATH=`dirname $SELF_ABS`
SELF=$( basename $0 )
SELF_LONG=$( printf "$0" | sed 's|./||g')

# include some handy functions
requirements="sed grep printf cut sort php echo clear curl"

#############################################################3
# Embedded variables
# :basedomain=www.google.com:
# :basedir=.:
# :email=your@email.com:
# :logfile=log/test.txt:
# :cookie=log/test.cookie.txt:
# :cookiejar=log/test.cookie.jar.txt:
# :error=ERROR: '10-client.senddata':
# :error_count=1:
# :warning_count=0:
# :error_treshold=3:
# :last_url=0:
# :curlargs=:
# :verbose=:

_strstr (){
    # if s2 points to a string of zero length, strstr echoes s1
    [ ${#2} -eq 0 ] && { return 1; }
    # strstr echoes nothing if s2 does not occur in s1
    case "$1" in
    *$2*) ;;
    *) return 1;;
    esac
    # use the pattern matching code to strip off the match and everything
    # following it
    first=${1/$2*/}
    # then strip off the first unmatched portion of the string
    #echo "${1##$first}"
    return 0;
}

checkrequirements(){
  for req in $requirements; do 
    hash "$req" 2>&-
    if [ $? == 1 ]; then echo "sorry..you need to install '$req'"; exit; fi
  done;
}

_throw-warning () {
  printf "$C_YELLOW[!] WARNING: $C_RESET$1\n"
  if [ -f "$2" ] ; then
    cat "$2" >> "$2.errors"
  fi
  local count=$WARNING_COUNT
  ((count++))
  export WARNING_COUNT=$count
}

_throw-error () {
  printf "\E[1;31;40m[!] ERROR: \E[0;37;40m$1\n"
  if [ -f "$2" ] ; then
    printf "\n$LAST_URL\n============================\n\n" >> "$2.errors"
    cat "$2" >> "$2.errors"
  fi
  count=$(_get-variable error_count)
  ((count=count+1))
  _set-variable error_count $count 
  _set-variable error "$1"
}

_throw-succes () {
  printf "$C_GREEN[!] OK: \E[0;37;40m$1\n"
}


_get-variable() {
 local var=$1
 grep "^# :$var=.*:$" $SELF_ABS | sed -e 's/# ://' -e 's/:$//' | cut -d '=' -f 2- | head -n 1
}

var_exists () {
 local var=$1
 grep -q "^# :$var=.*:$" $SELF_ABS
}

_set-variable () {
  local var val oldval file
  [[ ! -w $SELF_ABS ]] && echo "$SELF is read only" && exit 1
  var=$(echo $1 | sed -e 's/\(\.\|\/\|\*\|\[\|\]\|\\\)/\\&/g' )
  val=$(echo $2 | sed -e 's/\(\.\|\/\|\*\|\[\|\]\|\\\)/\\&/g' )
  var_exists $var || echo "$var doesn't exist" 
  oldval=$( _get-variable $var | sed -e 's/\(\.\|\/\|\*\|\[\|\]\|\\\)/\\&/g')

  if [ $# -lt 3 ] ; 
  then 
    echo "[x] variable '$var' set to '$2'"
    #[[ -z "$val" ]] && warn "new value is empty"
  fi  
  sed -i.bak -e "s/# :$var=$oldval:/# :$var=$val:/" $SELF_ABS
}

# (runs all tests, please provide testdirectory 'white' or 'gray')
all(){
  [[ ! -n "$1" ]] && usage && exit 1
  local logfile=$(_get-variable logfile)
  : > "$logfile.all"
  : > "$logfile" && : > "$logfile.errors" && : > "$logfile.links"
  # start tests
  _set-variable error "no errors" 1
  _set-variable error_count 0 1
  _set-variable warning_count 0 1 
  _set-variable last_url 0 1
  files=$(ls $SELF_PATH/tests/$1 | sort -n)
  for file in $files; do
    if [ ! -d "$file" ]; then 
      _runtest "$(basename $file)" "$1"
    fi 
  done 
  _all-overview
  errors=$?
  #printf "$C_RESET[x]\n[x] all stdout output stored in $C_BOLD$logfile.all$C_RESET"
  printf ", and last test-output $C_BOLD$logfile$C_RESET\n"
  exit $errors
}

_all-overview(){
  local BASEDIR=$(_get-variable basedir)
  local BASEURL=$(_get-variable baseurl)
  local USERNAME=leon
  local PASSWORD=secret
  local COOKIE=$(_get-variable cookie)
  local COOKIEJAR=$(_get-variable cookiejar)
  local LOGFILE=$(_get-variable logfile)
  local EMAIL=$(_get-variable email)
  local MAX_ERROR=$(_get-variable error_treshold)
  ERROR_COUNT=$(_get-variable error_count);
  WARNING_COUNT=$(_get-variable warning_count);
  ERROR=$(_get-variable error);

#  local reqs=$(_test-url-exists)
  printf "\n\E[1;33;40m[!] warnings: $WARNING_COUNT\E[0;37;40m\n"
  printf "\E[1;33;40m[!] errors  : $ERROR_COUNT\E[0;37;40m\n"
  if _strstr "$ERROR" "no errors" ; 
  then
    printf "\E[1;32;40m[!] software is feeling groovy! :)\E[0;37;40m\n"
  else
    local emails=$(_get-variable email | sed 's/,/ /g' )
    local loc=$(dirname $0)
    printf "\E[1;33;40m[!] last error: $ERROR\E[0;37;40m\n"
    printf "\E[1;33;40m[!] errors found! see logfiles '$LOGFILE*' for more info\E[0;37;40m\n"
    if [ ${#emails} != 0 ] ; then
      if [ $error_count -gt $MAX_ERROR ] ; then
        for i in $emails
        do
          echo "sending email to '$i'"
          printf "last error: $ERROR\n\n" > /tmp/log.txt
          cat "$LOGFILE.errors" >> /tmp/log.txt
          mail -s "$loc/$SELF testsuite failed" $i < /tmp/log.txt
          rm /tmp/log.txt
        done
      fi
    else
      echo "no emails sent (use './$SELF set-variable email <your@email.com,other@email.com> )"
      echo "               (use './$SELF set-variable error_treshold <number-of-errors-before-emailing> )"
    fi
    return 1
  fi
  return 0
}

usage(){
  local files="$0"
  printf "Usage: \n"
  for file in $SELF_PATH/tests/white/*; do if [ ! -d "$file" ]; then files="$files $file"; fi; done
  for file in $SELF_PATH/tests/gray/*; do if [ ! -d "$file" ]; then files="$files $file"; fi; done
  for file in $files; do
    grep "^[^_].\+(){$" $file | while read line; do
      local cmd=$(echo "$line" | sed "s/(){//g")
      local info=$(grep -C0 -A0 -B1 "$cmd(){" $file | sed "N;s/\n.*//g" )
      printf "    $SELF %-25s %-25s\n" "$cmd" "$info" | grep "#" | sed "s/#//g"
    done; 
  done
  tests=" (available tests: \n\n"
  for i in $SELF_PATH/tests/white/*; do [[ ! -d "$i" ]] && tests="$tests\t\t\t\t\t\twhite/$(basename $i)\n"; done
  for i in $SELF_PATH/tests/gray/*; do [[ ! -d "$i" ]] && tests="$tests \t\t\t\t\t\tgray/$(basename $i)\n"; done
  printf "    $SELF %-25s %-25s\n" "<test>" "$( printf "$tests\t\t\t\t\t)" | sed 's/: ,/: /g')"
  printf "\ntype '$SELF --manual' to see the manual + examples\n"
  return 0
}

manual(){
  if [ "$1" != "--manual" ]; then return 0; fi
  hash pod2man 2>&-
  if [ $? == 1 ]; then echo "sorry..you need to install 'pod2man' (perl)"; exit; fi
  SCRIPT=`readlink -f $0`
  echo "(please wait..)"
  pod2man $SCRIPT > /tmp/xdebug.1
  clear
  if [ -f /tmp/xdebug.1 ]; then man /tmp/xdebug.1; rm /tmp/xdebug.1; fi
  exit 0
}

# (shows the configuration of the testing engine)
config(){
  settings
}

_export-settings(){
  export BASEDIR=$(_get-variable basedir)
  export BASEDOMAIN=$(_get-variable basedomain)
  export BASEURL="http://$BASEDOMAIN"
  export USERNAME=leon
  export PASSWORD=secret
  export COOKIE=$(_get-variable cookie)
  export COOKIEJAR=$(_get-variable cookiejar)
  export LOGFILE=$(_get-variable logfile)
  export EMAIL=$(_get-variable email)
  export ERROR_COUNT=$(_get-variable error_count)
  export ERROR=$(_get-variable ERROR)

}

_runtest(){
  _export-settings
  printf "\n$C_BOLD$C_GREEN==> $C_WHITE$1$C_RESET\n"
  cd $SELF_PATH/tests/$2
  [[ ! -d "$1" ]] && ./$1 
  [[ "$?" == 1 ]] && _throw-error "ERROR: '$1'" 
  [[ "$?" > 1  ]] && _throw-warning "WARNING: '$1'" 
  cd - 1>/dev/null 2>&1
}

##### MAIN ###############################################################################
#
# only do something if not included by other bashscript 
#
export LOGFILE=$(_get-variable logfile)
if [[ "$(basename $0)" == "test" ]]; then 
  checkrequirements && manual "$1" && test $# -lt 1 && usage && exit 65
  #include libs and tests
  BASEDIR=$(dirname $0)
  # run test if requested, or perform internal cmd
  if [[ -f "$SELF_PATH/tests/$1" ]]; then _runtest "$1"; 
  else "$@" | tee "$LOGFILE"; fi
    
  exit 0  
fi 

# the manual
: <<=cut
=head1 NAME

   test - a utility to facilitate white/graybox regression testing

=head1 SYNOPSIS

   This utility enables white- gray- black- and sandboxtesting any 
   site.

=head1 DESCRIPTION

Grayboxtest easifies (automated) testing of functionality.

=head1 WHY

Because quality matters, to save our developer's butts.

=head1 EXAMPLES

Examples: whiteboxtest all


=head1 SEE ALSO

build

=head1 LICENSE

Unknown

=head1 AUTHORS

B<L>eon B<v>an B<K>ammen | info@leon.vankammen.eu

=cut
